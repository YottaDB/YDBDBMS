load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
}

@test "select wildcard columns" {
  run octo <<OCTO
select * from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
}

@test "select columns via short name" {
  run octo <<OCTO
select firstName, lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select columns via long name" {
  run octo <<OCTO
select names.firstName, names.lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select column which doesn't exist" {
  octo <<OCTO &> output.txt
select names.hackName from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Unknown column" ]]
}

@test "select column with invalid typing" {
  octo <<OCTO &> output.txt
select names.firstName + 5 from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Type mismatch" ]]
}

@test "select with a semicolon in string" {
  octo <<OCTO &> output.txt
select * from names where firstName = "; hello world";
OCTO
  run cat output.txt
  ! [[ "$output" =~ "ERROR" ]]
  [[ $(grep -c "|" output.txt) == "0" ]]
}

# @test "select from table with multiple keys" {
#   octo <<OCTO &> output.txt
# create table names2 (
#   id INTEGER PRIMARY KEY,
#   firstName VARCHAR(30) KEY NUM 1,
#   lastName VARCHAR(30) KEY NUM 2
# );
# insert into names2 (select * from names where firstName <> "" AND lastName <> "");
# select * from names2;
# OCTO
#   run cat output.txt
#   [[ "$output" =~ "Zero|Cool" ]]
# }
# 

@test "select without a from statement" {
  octo <<OCTO &> output.txt
select 17+5*5;
OCTO
  [[ $( grep -c "42" output.txt) == "1" ]]
}

@test "select without a from with a syntax error" {
  octo <<OCTO &> output.txt
select * asdfasdfsdf;
OCTO
  [[ $( grep -c "ERROR" output.txt) == "1" ]]
}

@test "select so many columns it would exceed the M line length" {
  octo -vv <<OCTO &> output.txt
SELECT firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName
FROM names;
OCTO
}

@test "select using a CASE statement" {
  octo <<OCTO &> output.txt
SELECT
  firstName
  , CASE firstName
    WHEN "Zero" THEN "Zero Cool"
    WHEN "Acid" THEN "Acid Burn"
    WHEN "Cereal" THEN "Cereal Killer"
    ELSE firstName
    END
FROM names;
OCTO
  [[ "$(grep -c "Zero" output.txt)" == "3" ]]
}

@test "select a negative number" {
  octo <<OCTO &> output.txt
SELECT -5
FROM names;
OCTO
  [[ "$(grep -c -- "-5" output.txt)" != "0" ]]
}

@test "select some columns with C-style comments interwoven" {
  octo <<OCTO &> output.txt
SELECT firstName /* We need first names */
  , lastName /* We also need last names */
  /* It might also be helpful to get id
   * but mostly because it lets me test multiline
   * comments */
  , id
# We're going to try a different kind of comment here, just because
FROM names;
OCTO
  [[ "$(grep -c "|" output.txt)" == "6" ]]
}

@test "order by a calculated column" {
  octo <<OCTO &> output.txt
SELECT nspname AS TABLE_SCHEM,
  NULL AS TABLE_CATALOG
FROM pg_catalog.pg_namespace
WHERE nspname <> 'pg_toast'
  AND (nspname !~ '^pg_temp_'  OR nspname = (pg_catalog.current_schemas(true))[1])
  AND (nspname !~ '^pg_toast_temp_'  OR nspname = 
    replace((pg_catalog.current_schemas(true))[1], 'pg_temp_', 'pg_toast_temp_'))
ORDER BY TABLE_SCHEM;
OCTO
  [[ "$(grep -c "|" output.txt)" == "3" ]]
}
